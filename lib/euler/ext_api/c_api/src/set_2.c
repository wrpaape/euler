/************************************************************************************
 *                                     set_2.c                                      *
 *                                                                                  *
 * Module housing solutions to problems 11-20                                       *
 ************************************************************************************/
/************************************************************************************
 *                             PREPROCESSOR DIRECTIVES                              *
 ************************************************************************************/
#include "sets.h"
#include "set_2.h"
/************************************************************************************
 *                               TOP LEVEL FUNCTIONS                                *
 ************************************************************************************/
/************************************************************************************
 *                                  - problem_12 -                                  *
 * 																																									*
 * The sequence of triangle numbers is generated by adding the natural numbers. So	*
 * the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten		*
 * terms would be:																																	*
 * 																																									*
 * 2, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...																					*
 * 																																									*
 * Let us list the factors of the first seven triangle numbers:											*
 * 																																									*
 *  1: 1																																						*
 *  3: 1,3																																					*
 *  6: 1,2,3,6																																			*
 * 10: 1,2,5,10																																			*
 * 15: 1,3,5,15																																			*
 * 21: 1,3,7,21																																			*
 * 28: 1,2,4,7,14,28																																*
 * We can see that 28 is the first triangle number to have over five divisors.			*
 * 																																									*
 * What is the value of the first triangle number to have over five hundred					*
 * divisors? 																																				*
 ************************************************************************************/
void problem_12(char *result_buffer)
{
	unsigned int n;						/* counter for calculating triangule number 'tri_num' */
	unsigned int tri_num;	    /* triangle number corresponding to counter 'n' */
	unsigned int num_divs;		/* number of divisors for 'tri_num' */
	unsigned int smaller_div; /* smaller of two divisors whose product is 'tri_num' */
	unsigned int min_big_div; /* current smallest larger divisor */

	const unsigned int N = 10; /* max number of iterations */

  n        = 0; /* zeroth counter */
  tri_num  = 0; /* zeroth triangle number */
  num_divs = 1; /* corresponds to 'tri_num' of 0 */ 

  while (num_divs < 500) {
    ++n;                   /* increment counter */
    tri_num    += n;       /* calculate next triangle number */
    smaller_div = 1;       /* set first smaller divisor to 1 */
		min_big_div = tri_num; /* set smallest bigger divisor to 'tri_num' */
		num_divs    = 2;       /* corresponds to divisors 1 and 'tri_num' */

    while (smaller_div <= min_big_div) {
      ++smaller_div;

      if (tri_num % smaller_div == 0) {
        min_big_div = tri_num / smaller_div;
        num_divs += 2;
      }
    }
	}

  sprintf(result_buffer, "%u", tri_num); /* copy result to buffer */
}



/************************************************************************************
 *                                  - problem_13 -                                  *
 * 																																									*
 * Work out the first ten digits of the sum of the following one-hundred 50-digit   *
 * numbers. (DIG_MAT)                                                               *
 ************************************************************************************/
void problem_13(char *result_buffer)
{
  unsigned int *result;   /* points to array of decimal digits of current total sum */
  unsigned int off_num;   /* number position counter (x-coordinate) */
  unsigned int off_dig;   /* digit place counter (y-coordinate) */
  unsigned int off_ten;   /* index of tenth sig digit in final result */
  unsigned int res_buf_i; /* index of current char in 'result_buffer' */

  /* 100 ✕ 50 array of digits representing 100 50-digit numbers */
  const unsigned int DIG_MAT[100][50] = DIGITS;

  /* allocate memory for 50 digits + 2 extra digits for overflow, init all to 0 */
  result = handle_calloc(52, sizeof(unsigned int));
  /* result = calloc(52, sizeof(unsigned int)); */
  /* if (result == NULL) { */
  /*   mem_error(sizeof(unsigned int) * 52); */
  /* } */

  /* staring from the ones digits, add next number to 'result', propogating overflow */
  for (off_dig = 51; off_dig > 1; --off_dig) {
    for (off_num = 0; off_num < 100; ++off_num) {
      result[off_dig] += DIG_MAT[off_num][off_dig - 2]; /* sum column of digits */
    }
    /* carry remainder of 2+-digit sums */
    result[off_dig - 1] += (result[off_dig] / 10);      /* shift overflow left */
    result[off_dig]     %= 10;                          /* set digit to remainder */
  }

  /* account for overflow and set 'off_dig' to position of first non-zero sig digit */
  while (result[off_dig] > 9) {
    /* carry remainder of 2+-digit sums */
    result[off_dig - 1] += (result[off_dig] / 10);      /* shift overflow left */
    result[off_dig]     %= 10;                          /* set digit to remainder */
    --off_dig;
  }

  /* copy first ten significant digits to buffer */
  for (res_buf_i = 0; res_buf_i < 10; ++res_buf_i, ++off_dig) {
    /* offset value of char '0' by current digit to convert to ASCII char */
    result_buffer[res_buf_i] = '0' + result[off_dig];
  }
}


/************************************************************************************
 *                                  - problem_14 -                                  *
 * 																																									*
 * The following iterative sequence is defined for the set of positive integers:    *
 *                                                                                  *
 * n → n/2 (n is even)                                                              *
 * n → 3n + 1 (n is odd)                                                            *
 *                                                                                  *
 * Using the rule above and starting with 13, we generate the following sequence:   *
 *                                                                                  *
 * 13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1                                       *
 * It can be seen that this sequence (starting at 13 and finishing at 1) contains   *
 * 10 terms. Although it has not been proved yet (Collatz Problem), it is thought   *
 * that all starting numbers finish at 1.                                           *
 *                                                                                  *
 * Which starting number, under one million, produces the longest chain?            *
 *                                                                                  *
 * NOTE: Once the chain starts the terms are allowed to go above one million.       *
 ************************************************************************************/
void problem_14(char *result_buffer)
{
  unsigned int n0;           /* number at start of sequence defined above */
  unsigned int n;            /* current number in sequence defined above */
  unsigned int count;        /* length of current sequence */
  unsigned int max_count;    /* length of longest sequence */
  unsigned int n0_max_count; /* starting number that produces 'max_count' */

  n0           = 1e6;
  max_count    = 0;
  n0_max_count = 0;

  while (n0 > 1) {
    --n0;       /* decrement n0 */
    n     = n0; /* initialize n */
    count = 2;  /* including initial and final values */

    while (n > 1) {
      if ((n & 1) == 1) {  /* n is odd */
        n = 3 * n + 1;
      } else {             /* n is even */
        n = n / 2;
      }
      ++count;
    }

    if (count > max_count) {
      max_count    = count;
      n0_max_count = n0;
    }
  }

  sprintf(result_buffer, "%u", n0_max_count);
}


/************************************************************************************
 *                                  - problem_15 -                                  *
 * 																																									*
 * Starting in the top left corner of a 2×2 grid, and only being able to move to    *
 * the right and down, there are exactly 6 routes to the bottom right corner.       *
 * 																																									*
 * How many such routes are there through a 20×20 grid?                             *
 ************************************************************************************/
void problem_15(char *result_buffer)
{
  unsigned int n;                    /* counter indicating current grid size (n✕n) */
  long long unsigned int num_routes; /* central bionomial coefficent */
  long long unsigned int adjacent;   /* adjacent number in sequence (see below) */

  /*****************************************************************
   *  n   ║ last num_routes ║ (n - 1) / n ║ adjacent ║ num_routes  *
   * ═════╬═════════════════╬═════════════╬══════════╬════════════ *
   *  1   ║        ∅        ║             ║    ∅     ║     2       *
   *  ↓   ║                 ║             ║          ║  ↙          *
   *  + 1 ║                 ║             ║          +             *
   *  ↓   ║                 ║             ║       ↙  ║             *
   *  2   ║        2        →     ✕ ½     →    1  → ✕ 2 →  6       *
   *  ↓   ║                 ║             ║          ║  ↙          *
   *  + 1 ║                 ║             ║          +             *
   *  ↓   ║                 ║             ║       ↙  ║             *
   *  3   ║        6        →     ✕ ⅔     →    4  → ✕ 2 →  20      *
   *  ↓   ║                 ║             ║          ║  ↙          *
   *  + 1 ║                 ║             ║          +             *
   *  ↓   ║                 ║             ║       ↙  ║             *
   *  4   ║        20       →     ✕ ¾     →    15 → ✕ 2 →  70      *
   *  ⋮   ║        ⋮        ║             ║    ⋮     ║     ⋮       *
   ****************************************************************/

  num_routes = 2; /* staring with 2 possible routes for a 1✕1 grid... */

  /* from a 2✕2 to a 20✕20 grid... */
  for (n = 2; n < 21; ++n) {
    adjacent = num_routes * (n - 1) / n;      /* calculate next 'adjacent' number */

    num_routes = 2 * (num_routes + adjacent); /* calculate 'num_routes' for 'n' */
  }

  sprintf(result_buffer, "%llu", num_routes); /* copy result to buffer */
}

/**********************************************************************************
 *                                 - problem19 -                                  *
 *                                                                                *
 * You are given the following information, but you may prefer to do some         *
 * research for yourself.                                                         *
 *                                                                                *
 * 1 Jan 1900 was a Monday.                                                       *  
 * Thirty days has September,                                                     *  
 * April, June and November.                                                      *  
 * All the rest have thirty-one,                                                  *  
 * Saving February alone,                                                         *  
 * Which has twenty-eight, rain or shine.                                         *  
 * And on leap years, twenty-nine.                                                *  
 * A leap year occurs on any year evenly divisible by 4, but not on a century     *  
 * unless it is divisible by 400.                                                 *
 *                                                                                *
 * How many Sundays fell on the first of the month                                *
 * during the twentieth century (1 Jan 1901 to 31 Dec 2000)?                      *
 **********************************************************************************/
void problem_19(char *result_buffer)
{
  int year;                     /* index equal to current year */
  int month_i;                  /* index for tracking current month */
  int rem_month_days;           /* days remaining in current month */
  int is_leap_year;             /* guard clause boolean */
  int is_20th_cent;             /* guard clause boolean */
  unsigned int sunday_count;    /* number of Sundays on 1st of month (result) */
  struct DayNode *curr_day_ptr; /* points to current day in circular day cycle */

  /* name and (regular) number of days of every month */
  const struct Month months[MONTHS_PER_YEAR] = {
    {.name = JANUARY,   .num_days = 31}, {.name = FEBRUARY, .num_days = 28},
    {.name = MARCH,     .num_days = 31}, {.name = APRIL,    .num_days = 30},
    {.name = MAY,       .num_days = 31}, {.name = JUNE,     .num_days = 30},
    {.name = JULY,      .num_days = 31}, {.name = AUGUST,   .num_days = 31},
    {.name = SEPTEMBER, .num_days = 30}, {.name = OCTOBER,  .num_days = 31},
    {.name = NOVEMBER,  .num_days = 30}, {.name = DECEMBER, .num_days = 31}
  };

  curr_day_ptr = init_day_cycle(); /* begin on a Monday */
  is_20th_cent = false;            /* init state (Mon 01/01/1900) is 19th century */
  sunday_count = 0;

  /* from January 1st, 1900 through the 20th century... */
  for (year = 1900; year < 2001; ++year) {
    /* is the current year a leap year? */
    if (year % 100 == 0) {
      is_leap_year = (year % 400 == 0) ? true : false;
    } else {
      is_leap_year = (year %   4 == 0) ? true : false;
    }
    /* for every month of the year, starting at January... */
    for (month_i = 0; month_i < MONTHS_PER_YEAR; ++month_i) {
      /* is the current day (1st of the month) a Sunday (in the 20th century)? */
      if ((curr_day_ptr -> name) == SUNDAY && is_20th_cent) {
        ++sunday_count; /* increment 'sunday_count' */
      }
      /* if it's a leap year and the current month is February... */
      if (is_leap_year && (months[month_i].name == FEBRUARY)) {
        rem_month_days = 29; /* set month days to 29 */
      } else {
        rem_month_days = months[month_i].num_days;
      }
      /* cycle through one current month's worth of days */
      while (rem_month_days > 0) {
        curr_day_ptr = curr_day_ptr -> next_ptr;
        --rem_month_days;
      }
    }
    /* set 20th century after first iteration */
    if (!is_20th_cent) {
      is_20th_cent = true;
    }
  }

  sprintf(result_buffer, "%u", sunday_count); /* copy result to buffer */
}

/**********************************************************************************
 *                               - init_day_cycle -                               *
 *                                                                                *
 * Helper function to 'problem_19', returns a circular list of 'DayNode's which   *
 * model the current day of the week ('name') and point to the following day      *
 * ('next_ptr').                                                                  *
 **********************************************************************************/
struct DayNode *init_day_cycle(void)
{
  int day_i;                                /* index for tracking current day */
  struct DayNode *day_cycle;                /* pointer to array of DayNodes */
  const int LAST_DAY_I = DAYS_PER_WEEK - 1; /* index of last day (5) */
  /* bytes required for 7 DayNodes */
  const size_t DAY_CYCLE_SIZE = sizeof(struct DayNode) * DAYS_PER_WEEK;
  /* array of 'DayName' enums representing the names of the days of the week */
  const enum DayName day_names[DAYS_PER_WEEK] = {
    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
  };
  /* allocate contiguous memory for a week's worth of DayNodes */
  day_cycle = handle_malloc(sizeof(struct DayNode) * DAYS_PER_WEEK);
  /* day_cycle = malloc(DAY_CYCLE_SIZE); */
  /* if (day_cycle == NULL) { */
  /*   mem_error(DAY_CYCLE_SIZE); */
  /* } */
  /* For every day of the week, starting on Monday... */
  day_i = 0;
  while (1) {
    /* init next DayNode's const enum field, 'name' */
    struct DayNode day_node = {
      .name = day_names[day_i],
    };
    /* if not on last day, connect current DayNode to next memory space */
    if (day_i < LAST_DAY_I) {
      day_node.next_ptr = &day_cycle[day_i + 1];
      day_cycle[day_i]  = day_node;
      ++day_i;
      continue;
    }
    /* connect final DayNode (Sunday) to head (Monday) and return */
    day_node.next_ptr = &day_cycle[0];
    day_cycle[LAST_DAY_I] = day_node;

    return day_cycle; /* return pointer pointing to start of DayNode array */
  }
}
